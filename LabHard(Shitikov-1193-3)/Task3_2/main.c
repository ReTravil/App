/*----------------------------------------------------------------------------------------------------------------------------------------
**Проект: "Удаленный контроль за скоростью мигания светодиодов".
**Назначение программы: псевдопараллельное выполнение двух задач:
**																									* мигание светодиодов;
**																									* программный контроль в терминале PuTTY за частотой мигания светодиодов.
**Разработчик: Шитиков Дмитрий Андреевич - 1193б
**Цель: создание программы, использующей внутренние прерывания микроконтроллера STM32F072RBT 
**Решаемые задачи:
**		1. Реализация функции-обработчика внутреннего прерывания микроконтроллера STM32F072RBT (USART);
**		2. Конфигурирование NVIC;
**		3. Настройка модуля USART на генерацию сигнала прерывания при возникновении заданных событий;
**		4. Конфигурирование частоты мигания светодиодов c удаленным доступом.
**----------------------------------------------------------------------------------------------------------------------------------------*/
																															//
#include "main.h"																							//
static uint16_t temp = 5;																			//	Объявление переменнной временного счетчика 
static int8_t counter = 0;																		//	Объявление переменной счетчика введенных символов
static uint16_t half_period_array[] = {0, 5, 0, 0, 0, 0};			//	Базовая конфигурация в 50000 мкс с помощью массива
static uint16_t temp_array[] = {0, 0, 0, 0, 0, 0};						//	Дополнительный массив для заполнения при нажатии цифр(цифры которые вводятся с клавиатуры будут помещены сюда)
static uint16_t cur_value[] =  {208, 191, 208, 181, 209, 128,	//	Массив содержащий сообщени "период мигания, мкс: "(кирилица в ASCII)
																208, 184, 208, 190, 208,			//
																180, 32, 208, 188, 208,				//
																184, 208, 179, 208, 176,			//
																208, 189, 208, 184, 209,			//
																143, 44, 32, 208, 188, 208,		//
																186, 209, 129, 58, 32, 0};		//
static uint16_t new_value[] =  {208, 189, 208, 190, 208, 178,	//	Массив содержащий сообщени "новое значение, мкс: "(кирилица в ASCII)
																208, 190, 208, 181, 32,				//
																208, 183, 208, 189, 208,			//
																176, 209, 135, 208, 181,			//
																208, 189, 208, 184, 208,			//
																181, 44, 32, 208, 188,				//
																208, 186, 209, 129, 58, 32};	//
int main()																										//
{																															//
	__disable_irq();																						//	Глобальное запрещение прерываний
																															//	Настройка порта GPIOB для контроля светодиода
	RCC->AHBENR|=RCC_AHBENR_GPIOBEN;														//	Включение тактирования порта В
	GPIOB->MODER|= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER8_0; 	//	Переключение линий 0 и 8 порта В в режим "Output"
	GPIOB->MODER&=~ (GPIO_MODER_MODER12 | GPIO_MODER_MODER13);	//	Переключение линий 12(SW4) и 13(SW3) порта В в режим "Input"
	GPIOB->ODR|=0x100;																					//	Разрешение работы светодиодов на стенде CТМ_01 с помощью установки логической "1" на выводе РВ.8									
																															//
	InitUSART1();																								//	Инициализация модуля USART1
	NVIC->ISER[0] |= 0x08000000; 																//	Разрешение в NVIC прерывания от модуля USART1(27 бит)	
	__enable_irq();																							//	Глобальное разрешение прерываний 
																															//
	while(1){																										//
		uint32_t half_period = 0;																	//	Объявление переменной, получаеющей данные из массива(cur_value)
		for (int32_t i = 5, j = 0; i >-1; i --, j++){							//	Получение данных из массива half_period_array
			half_period += half_period_array[i] * pov(10, j);				//	Поразрядное увеличение переменной
		}																													//
		GPIOB->BSRR=0x1;																					//	Включение светодиода 
		delay(half_period);																				//	Задержка
		GPIOB->BSRR=0x10000;																			//	Выключение светодида
		delay(half_period);																				//	Задержка
	}																														//
}																															//
void InitUSART1(){																						//	Настройка модуля USART1
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;												//	Включение тактирования USART1
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;													//	Включение тактирования порта А
																															//
																															//	Настройка линий порта А: РА9(ТХ_1) - выход передатчика; PA10(RX_1) - вход приёмника
	GPIOA->MODER |= 0x00280000;																	//	Перевести линии РА9 и РА10 в режим альтернативной функции
	GPIOA->AFR[1] |= 0x00000110;																//	Включить на линиях РА9 и РА10 альтернативную функцию AF1
																															//
																															//	Настройка линии передатчика Тх (РА9)
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_9;													//	Сбросить 9 бит GPIOA->OTYPER - переключение в режим push-pull для линии РА9 (активный выход) 
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR9;													//	Отключение подтягивающих резисторов для линии РА9 
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDR9;										//	Установка высокой скорости синхронизации линии РА9
																															//
																															//	Настройка линии приемника Rx (РА10)
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR10;												//	Сброс режима подтягивающих резисторов для линии РА10
	GPIOA->PUPDR |= GPIO_PUPDR_PUPDR10_0;												//	Включение подтягивающего резистора pull-up на входной линии РА10 (вход приемника Rx)
																															//
																															//	Конфигурирование USART
	USART1->CR1 &= ~USART_CR1_UE;																//	Запрещение работы модуля USART1 для изменения параметров его конфигурации
	USART1->BRR=69;																							//	Настройка делителя частоты, тактирующего USART и задающего скорость приема и передачи данных на уровне 115200 бит/с: 
																															//	Частота тактирующего генератора = 8 МГц 
																															//	Скорость обмена по USART - 115200 бит/с; коэффициент деления - 8000000 / 115200 - 69,4444(4); Округленное значение - 69
	USART1->CR1 = USART_CR1_TE | USART_CR1_RE;									//	Разрешить работу приемника и передатчика USART. Остальные биты этого регистра сброшены, что обеспечивает: 
																															//	количество бит данных в пакете 8;
																															//	контроль четности - отключен; 
																															//	прерывания по любым флагам USART - запрещены;
																															//	состояние USART - отключен
	USART1->CR1 |= USART_CR1_RXNEIE | USART_CR1_TCIE; 					//	Разрешение (в модуле USART1) на выдачу сигнала прерывания при возникновении событий:
																															//	прием кадра в буферный регистр; завершение передачи кадра
	USART1->CR2 = 0;																						//	Количество стоповых бит - 1
	USART1->CR3 = 0;																						//	DMA1 - отключен
	USART1->CR1 |= USART_CR1_UE;																//	По завершении конфигурирования USART разрешить его работу (биту UE регистра CR1 присвоить 1)
}																															//
																															//	Функция задержки: count - количество элементарных периодов задержки с длительностью примерно 2.5 мкс 
void delay(uint32_t count)																		//
{																															//
	for (uint32_t i=0;i<count;i++);															//	Выполнение пустых циклов для реализации программной задержки
}																															//
																															//
																												    	//	Функция-обработчик прерывания от модуля USART1 
void USART1_IRQHandler(void)                                  //
{																															//
	uint8_t pack;																								//  Переменная в которую записываем пакет принятьый USART1
																															//	Событие готовности принятых данных к чтению 
	if (USART1->ISR & USART_ISR_RXNE) { 												//	Если в регистре состояний USART1 установлен флаг "RXNE", то
		pack=(uint8_t)USART1->RDR; 																//	Чтение принятого битового пакета из буферного регистра приемника USART1 
			if (pack == 13){																				//	Если битовый пакет соответствует клавише Enter
				if (counter != 0){																		//	Если было введено какое-либо значение
					temp = 5;																						//	Временный счетчик устанавливается в 5, для отсчета из конца временного массива
					for (int i = 0; i < 6; i ++){												//	
						half_period_array[i] = 0;													//	Сброс постоянного массива в 0
					}																										//
					while (counter > 0){																//	Перевод данных из временного массива в постоянный, пока счетчик не обнулится
						half_period_array[6-counter] = temp_array[temp];	//	
						while((USART1->ISR & USART_ISR_TXE) == 0){}				//
						USART1->TDR = 127;																//	Стирание введенного числа
						temp--;																						//	Убавление временного счетчика
						counter--;																				//	Убавление счетчика
					}																										//
				}																											//
				while((USART1->ISR & USART_ISR_TXE) == 0){}	  				//	Подача битового пакета для клавиши Up
				USART1->TDR = 27;																			//			первый пакет
				while((USART1->ISR & USART_ISR_TXE) == 0){}						//
				USART1->TDR = 91;																			//			второй пакет
				while((USART1->ISR & USART_ISR_TXE) == 0){}						//
				USART1->TDR = 65;																			//			третий пакет
				counter = 0;																					//	Сброс счетчика в 0
				temp = 0;																							//	Сброс временного счетчика в 0
																				                     	//
				while((USART1->ISR & USART_ISR_TXE) == 0){}						//
				USART1->TDR = 13;																			//	Сдвиг каретки в крайнее левое положение
				for (int i = 0; i < 38; i ++){												//	Вывод массива с сообщением "период мигания, мкс:"
					while((USART1->ISR & USART_ISR_TXE) == 0){}					//
					USART1->TDR = cur_value[i];													//
				}																											//
				for (int i = 0; i < 6; i ++){													//	Вывод массива с данными о периоде мигания
					while((USART1->ISR & USART_ISR_TXE) == 0){}					//
					USART1->TDR = half_period_array[i] + 48;						//
				}																											//
				while((USART1->ISR & USART_ISR_TXE) == 0){}						//
				USART1->TDR = 10;																			//	Перенос строки
				while((USART1->ISR & USART_ISR_TXE) == 0){}						//
				USART1->TDR = 13;																			//	Сдвиг каретки
																															//
				for (int i = 0; i < 38; i ++){												//	Вывод массива с сообщением "новое значение, мкс:"
					while((USART1->ISR & USART_ISR_TXE) == 0){}					//
					USART1->TDR = new_value[i];													//
				}																											//
				for (int i = 0; i < 6; i ++){													//	Сброс временного массива в 0
					temp_array[i] = 0;																	//
				}																											//
			}																												//
			else if (pack == 127 && counter > 0){										//	Если битовый пакет соответсвует клавише Backspace и было введено что-либо
				while ((USART1->ISR & USART_ISR_TXE) == 0) {}					//
				USART1->TDR = pack;																		//	Стирание символа
				counter--;																						//	Уменьшение счетчика на 1
			}																												//
			else if ((pack >=0x30 && pack <= 0x39) && counter < 6){	//	Если битовый пакет соответсвует цифре и было введено не более 6 символов
				while ((USART1->ISR & USART_ISR_TXE) == 0) {}					//
					USART1->TDR = pack;																	//	Вывод битового пакет (цифры)
				temp_array[5-counter] = pack - 48;								  	//	Запись битового пакета, приведенного к значению числа, во временный массив
				counter++;																				  	//	Увеличени размера счетчика числа на 1
			}																												//
	}																														//
	if (USART1->ISR & USART_ISR_TC) {														//	Если в регистре состояний USART1 установлен флаг "ТС", то
																															//	Сброс флага завершения передачи кадра 
		USART1->ICR=USART_ICR_TCCF;																//	Сбросить флаг завершения передачи кадра, чтобы прерывание не сработало повторно
	}																														//
}																															//
uint32_t pov(int32_t x, int32_t n)														// pov() - функция вычисления степени числа (находится в открытом доступе). 																					                      			 	 																																											
{																															// Входные данные: x - число, возодимое в степень 																																		                      			 	 																																											
    if (n==0)																									// Если степень равна 0  																																															                      			 	 																																											
        return 1; 																						//  										возвращается 1. 																																							                      			 	 																																											
    else if (n==1	)																						// Если степень равна 1  																																															                      			 	 																																											
        return x;																							//                      возвращается число. 																																					                      			 	 																																											
    else if (n % 2 == 0 )																			// Если степень четная   																																															                     
			return pov( x * x, n/2);															  //                    производится рекурсия, во входных параметрах число умноженное само на себя и половина степени.                  
    else																											// Если степень нечетная 																																															                      			/
        return pov( x * x, n /2)*x;														//                       производится рекурсия, во входных параметрах число умноженное само на себя и половина степени. Результат умножается на число
 }																														// 																																																																																																																			*/
/*----------------------------------------------------------------------------------------------------------------------------------------
**Руководство пользователя:
**		1. Запустите программу на лабораторном комплексе;
**		2. На компьютере запустите приложение PuTTY и подключитесь к соответствующему COM-порту на скорости 115200 бит/с;
** 		3. При активном окне терминала для ввода доступны цифры, конфигурирующие частоту мигания светодиода в мкс, клавиша Backspace, стирающая ненужные значения, и клавиша Enter, подающая введенное значение мигания в контроллер;
**----------------------------------------------------------------------------------------------------------------------------------------*/
